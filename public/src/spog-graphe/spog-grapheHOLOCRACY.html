<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">

<!--
A COMPLETER AVEC  DANS LIB  : IMPORT / EXPORT, COMMANDES -->

<script src="../../bower_components/vis/dist/vis.js"></script>
<link rel="import" href="styles/vis-styles.html">
<link rel="import" href="styles/graphe-styles.html">

<script src="lib/commandes.js"></script>
<script src="lib/import-export.js"></script>

<dom-module id="spog-graphe">
  <template>
  <style include="graphe-styles"></style>
  <style include="vis-styles"></style>
  <style>
  #fabsetting {
    position: fixed;
    right: 25px;
    top: 100px;
  }

  </style>

  <div id="nodePopUp">
    <span id="nodeOperation">Ajouter ou modifier un noeud</span> <br>
    <table style="margin:auto;">
      <!--<tr>
      <td>id</td><td><input id="node-id" value="new value" /></td>
    </tr>-->
    <tr>
      <td>Nom du noeud</td><td><input id="nodeLabel"/></td>
    </tr>
  </table>
  <br>
  <input type="button" value="Valider" id="nodeSaveButton" />
  <input type="button" value="Annuler" id="nodeCancelButton" />
</div>

<div id="edgePopUp">
  <span id="edgeOperation">Ajouter ou modifier un lien</span> <br>
  <table style="margin:auto;">
    <tr>
      <td>Nom du lien</td><td><input id="edgeLabel" /></td>
    </tr>
  </table>
  <br>
  <input type="button" value="Valider" id="edgeSaveButton" />
  <input type="button" value="Annuler" id="edgeCancelButton" />
</div>

<div id="importPopUp">
  <span id="edgeOperation">Import JSON</span> <br>
  <table style="margin:auto;">
    <tr>
      <td><input type="checkbox" id="partageImport" checked="false">partager import</td>
      <td><input type="checkbox" id="remplaceNetwork" checked="false">remplacer network</td>
    </tr>
    <tr>
      <!--<td>label</td><td><input id="edgeLabel" value="new value" /></td>-->
      <td colspan="2">
        <input id="filepicker" on-change="_filesChanged" type="file" multiple value="Importer"></input>
      </td>
    </tr>
  </table>
  <!--  <input type="button" value="save" id="edgeSaveButton" />-->
  <input type="button" value="Annuler" id="importCancelButton" />
</div>

<div id="settings" hidden=true>
  <!--AJOUTER LE CHANGEMENT DE PHYSICS -->
  Gravité   <paper-slider  min="0" max="0.01" value="{{gravityValue}}" step="0.001" on-change="_changeGravity" ></paper-slider>
  Longueur des liens     <paper-slider  min="10" max="800" value="{{springLengthValue}}"  on-change="_changeSpringLength"></paper-slider>
  Force des liens   <paper-slider  min="0" max="0.2" value="{{springConstantValue}}"  step="0.001" on-change="_changeSpringConstant"></paper-slider>
  Distance entre deux noeuds     <paper-slider  min="10" max="800" value="{{nodeDistanceValue}}"  on-change="_changeNodeDistance"></paper-slider>
  Souplesse           <paper-slider  min="0.01" max="2" value="{{dampingValue}}"  step="0.01" on-change="_changeDamping"></paper-slider>
  <paper-button raised  on-tap="_defaultPhysicValues">Defaut</paper-button>
  <br><br>
</div>
<div id="mynetwork"></div>
<paper-fab id="fabsetting" on-tap="_toggleSettings"  label="set"></paper-fab>
<input id="inputMessage" class="inputMessage" on-change="traiteMessage" placeholder="Tapez votre triplet ici, précédé de :: ..." />
</template>

<script>
/**
* `spog-graphe`
*
*
* @customElement
* @polymer
* @demo demo/index.html
*/
class SpogGraphe extends Polymer.Element {
  static get is() { return 'spog-graphe'; }
  static get properties() {
    return {
      actionstosend: {
        type: Array,
        value: [],
        notify: true
      },
      socket: {
        type: Object,
        observer: "_socketChanged"
      },
      tickDelay: {
        type: Number,
        value: 100         // 15ms selon source, tempo pour envoi du snapshot par le serveur
      },
      db2populate:{
        type: Array,
        value: []
      },
      gravityValue :{
        type : Number,
        value: 0.001
      },
      springLengthValue :{
        type : Number,
        value: 220
      },
      springConstantValue :{
        type : Number,
        value: 0.05
      },
      nodeDistanceValue :{
        type : Number,
        value: 400
      },
      dampingValue :{
        type : Number,
        value: 0.08
      },
      fusekiresults: {
        type: Array,
        observer: '_fusekiresultsChanged'
      }
    };
  }

  ready() {
    super.ready();
    this.network = this.networkDivInitialize(this.$.mynetwork, this);

    // When possible, use afterNextRender to defer non-critical    // work until after first paint.
    /*Polymer.RenderStatus.afterNextRender(this, function() {
    //  console.log(this.network);
    //  this.network.fit();
    this.network.moveTo(this.network.body.data.nodes.get(1));
  });*/
  var app = this;
  app.tickInterval = setInterval(function() {
    if ((app.db2populate.length > 0) && (app.network != undefined)) {
      console.log(app.db2populate.length );
      //  console.log(app.network);
      app.populateVis(app.db2populate, app.network);
      //log(app.db2populate.length + "/" + app.tiplets2popLength);
      app.network.fit();
    }
  }, app.tickDelay);
  var network = this.network;
  this.network.on("selectNode", function(params) {
    console.log("select");
    console.log(params);
    if (params.nodes.length == 1) {
      if (network.isCluster(params.nodes[0]) == true) {
        network.openCluster(params.nodes[0]);
      }else if (params.nodes[0] == 15) {
        app._toggleDesc();
      }
    }
  });
  this._toggleDesc();
  console.log(this.network);

}

traiteMessage(){
  var message = this.$.inputMessage.value;
  console.log(message);
  if (message.startsWith("::")){
    this.catchTriplet(message, this.network);
    this.$.inputMessage.value = "::";
  }else if (message.startsWith("/")){
    var retourCommande = catchCommande(message,this.network);
    // implementer les commandes import, export, connexion endpoint...


  }
}

catchTriplet(message, network){

  console.log(message.length);
  message=message.trim();
  var tripletString = message.substring(2).trim().split(" ");
  // les noeuds existent-ils ?
  var sujetNode = network.body.data.nodes.get({
    filter: function(node){
      //    console.log(node);
      return (node.label == tripletString[0] );
    }
  });
  var objetNode = network.body.data.nodes.get({
    filter: function(node){
      //    console.log(node);
      return (node.label == tripletString[2]);
    }
  });
  console.log(sujetNode);
  console.log(objetNode);
  // sinon, on les créé
  if (sujetNode.length == 0){
    network.body.data.nodes.add({label: tripletString[0] });
  }
  if (objetNode.length == 0){
    network.body.data.nodes.add({ label: tripletString[2] });
  }
  // maintenant ils doivent exister, pas très po=ropre comme méthode , à revoir
  sujetNode = network.body.data.nodes.get({
    filter: function(node){
      console.log(node);
      return (node.label == tripletString[0] );
    }
  });
  objetNode = network.body.data.nodes.get({
    filter: function(node){
      console.log(node);
      return (node.label == tripletString[2]);
    }
  });
  var actionSujet = {};
  actionSujet.type = "newNode";
  actionSujet.data = sujetNode[0];
  //  actionsToSendTemp.push(actionSujet);
  this.addAction(actionSujet);
  var actionObjet = {};
  actionObjet.type = "newNode";
  actionObjet.data = objetNode[0];
  //  actionsToSendTemp.push(actionObjet);
  this.addAction(actionObjet);
  // maintenant, on peut ajouter l'edge
  network.body.data.edges.add({
    label: tripletString[1],
    from : sujetNode[0].id,
    to : objetNode[0].id
  });

  //on récupère ce edge pour l'envoyer au serveur
  var edge = network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == sujetNode[0].id && edge.to == objetNode[0].id && edge.label == tripletString[1]);
    }
  });
  var actionEdge = {};
  actionEdge.type = "newEdge";
  actionEdge.data = edge;
  this.addAction(actionEdge);
  //  actionsToSendTemp.push(actionEdge);
  //console.log(actionsToSendTemp);
  //  return actionsToSendTemp;

}

_socketChanged(s){
  console.log(s);
  var app = this;
  this.socket.on('tick', function(data){
    //  console.log(data);
    if (data.actions.length>0){
      data.actions.forEach(function(action) {
        //    console.log(action);
        switch(action.type) {
          case "newNode":
          if(app.network != undefined){
            app.addNodeIfNotExist(app.network, action.data);
          }
          break;
          case "editNode":
          break;
          case "deleteNode":
          app.deleteFromServer(action.data);
          break;
          case "newEdge":
          if(app.network != undefined){
            app.addEdgeIfNotExist(app.network, action.data);
          }
          break;
          case "editEdge":
          break;
          case "deleteEdge":
          app.deleteFromServer(action.data);
          break;
          default:
          console.log("action non reconnue");
          console.log(action);
        }
      });
    }
  });


  this.socket.on('initDb', function(db){
    console.log(db);
    app.db2populate = db;
    app.populateVis(app.db2populate, app.network);
    app.triplets2popLength = app.db2populate.length;
  });

  this.socket.on('initFuz', function(initFuz){
    console.log(initFuz);
  })

}

_fusekiresultsChanged(fusekiTriplets, oldValue){
  console.log(fusekiTriplets);
  console.log(this.network);
  var groupe = this.network.groups.groups.length+1;

  if(fusekiTriplets.length > 0){
    for (var i = 0; i < fusekiTriplets.length; i++) {
      var triplet = fusekiTriplets.pop();
      console.log(triplet);
      var sujetTemp = this.splitDecompose(triplet.Sujet);
      var proprieteTemp = this.splitDecompose(triplet.Predicat);
      var objetTemp = this.splitDecompose(triplet.Objet);
      //  console.log(sujetTemp);
      var sujetExist = this.network.body.data.nodes.get(sujetTemp.uri) || this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == sujetTemp.localName );
        }
      });
      var objetExist = this.network.body.data.nodes.get(objetTemp.uri)|| this.network.body.data.nodes.get({
        filter: function(node){
          return (node.label == objetTemp.localName );
        }
      });
      if (sujetExist == null || sujetExist.length == 0) {
        console.log("creation sujet");
        if (sujetTemp.localName.length > 40) {
          this.network.body.data.nodes.add({
            id: sujetTemp.uri,
            label: sujetTemp.localName.match(/.{1,40}/g).join("\n"),
            shape: "box",
            group: groupe
          });
        } else {
          var node = {
            id: sujetTemp.uri,
            label: sujetTemp.localName,
            group: groupe,
          };
          this.network.body.data.nodes.add(node);
        }
      }else{
        console.log("SUJET EXIST");
      }
      if (objetExist == null || objetExist.length == 0) {
        console.log("creation Objet ");
        if (objetTemp.localName.length > 40) {
          this.network.body.data.nodes.add({
            id: objetTemp.uri,
            label: objetTemp.localName.match(/.{1,40}/g).join("\n"),
            shape: "box",
            group: 0
          });
        } else {
          var node = {
            id: objetTemp.uri,
            label: objetTemp.localName,
            group: 0,
          };
          this.network.body.data.nodes.add(node);
        }
      }else{
        console.log("Objet EXIST");

        //    objetTemp = objetExist; //pkoi pas objetExist[0] ? objetExist retourne un objet alors que sujetExist un Array ???
      }



      // on recupere les noeuds, une fois qu'on est certain qu'ils sont créés
      var sujet = this.network.body.data.nodes.get(sujetTemp.uri) || this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.id == sujetTemp.id || node.label == sujetTemp.localName );
        }
      });
      var  objet = this.network.body.data.nodes.get(objetTemp.uri)|| this.network.body.data.nodes.get({
        filter: function(node){
          //    console.log(node);
          return (node.id == sujetTemp.id || node.label == objetTemp.localName );
        }
      });


      if(Array.isArray(sujet)){
        sujet = sujet[0];
      }

      if(Array.isArray(objet)){
        objet = objet[0];
      }
      console.log(sujet);
      console.log(objet);
      //  var edgeExist = [];
      // tester s'il exist dejà un lien identique entre les deux noeuds avec label
      //  edgeExist = this.network.body.data.edges.get(triplet.subject);
      //  if (edgeExist == null || edgeExist.length == 0) {
      var edge = {
        //  id: "",
        from: sujet.id,
        to: objet.id,
        label: proprieteTemp.localName,
        arrows: "to"
      };
      //edge.id = proprieteTemp.subject;
      //  edge[triplet.predicate] = triplet.object;
      this.network.body.data.edges.add(edge);

      console.log("»»»»»»»»»»»»»»»»»»»»»»»x");
      console.log(sujet);
      console.log(sujet.id+" >>- "+sujet.label);
      console.log(objet);
      console.log(objet.id+" --> "+objet.label);
      console.log(edge);
      console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
      //  } /*else {
      //  var edge = edgeExist;
      //    edge[triplet.predicate] = triplet.object;
      //    network.body.data.edges.update(edge);
      //  }*/
    }
  }

}

splitDecompose(binding){
  var binding = binding;
  var result = {};
  var type = binding.type;
  var prefix = binding.value.split("#")[0];
  var localName =  binding.value.split("#")[1];
  if (localName == undefined){
    prefix = binding.value.substring(0, binding.value.lastIndexOf("/") + 1);
    localName = binding.value.substring(binding.value.lastIndexOf("/") + 1, binding.value.length);
  }else{
    prefix = prefix+"#";
  }
  result.uri = binding.value;
  result.type = type;
  result.prefix= prefix;
  result.localName = localName;
  return result;
}



populateVis(db, network) {
  //  console.log("POPULATE");
  if (db.length > 0) {
    if (db.length % 100 < 5) {
      /*
      Rezoom tous les 100*/
      network.fit();
      network.redraw();
    }
    for (var i = 0; i < 10; i++) {
      var triplet = db.pop();
      if (triplet != undefined) {
        //  console.log(triplet);
        if (triplet.type == "node" && triplet.predicate == "label") {
          var noeudExist = network.body.data.nodes.get(triplet.subject);
          if (noeudExist == null || noeudExist.length == 0) {
            if (triplet.object.length > 40) {
              network.body.data.nodes.add({
                id: triplet.subject,
                label: triplet.object.match(/.{1,40}/g).join("\n"),
                shape: "box",
                group: 0
              });
            } else {
              var node = {
                id: triplet.subject,
                label: triplet.object,
                group: 0,
              };
              network.body.data.nodes.add(node);
              if ((node.label.toLowerCase() == "depart") || (node.label.toLowerCase() == "départ")) {
                //  console.log('trouve depart');
                //var nodeDep = network.body.data.nodes.get(triplet.subject);
                //console.log(nodeDep);
                //nodeDep.color = {background:'pink', border:'purple'};
                network.body.data.nodes.update({
                  id: triplet.subject,
                  color: {
                    background: 'pink',
                    border: 'purple'
                  }
                })
                var nodeDep = network.body.data.nodes.get(triplet.subject);
                /*nodeDep = network.body.data.nodes.get(triplet.subject);*/
                network.focus(nodeDep.id);
                network.fit();
              }
              if (node.label.match(/^\d/)) {
                // Return true if starts with number
                console.log(node.label);
                // first number
                var firstNum = node.label.split(".")[0];
                network.body.data.nodes.update({
                  id: triplet.subject,
                  group: firstNum
                });
              }

            }
          } else {
            console.log("exist : ");
            /*            console.log(noeudExist);
            noeudExist.mass++;
            console.log(noeudExist);*/
          }
        } else {
          var edgeExist = [];
          edgeExist = network.body.data.edges.get(triplet.subject);
          if (edgeExist == null || edgeExist.length == 0) {
            var edge = {
              id: "",
              from: "",
              to: "",
              label: "",
              arrows: "to"
            };
            edge.id = triplet.subject;
            edge[triplet.predicate] = triplet.object;
            network.body.data.edges.add(edge);
          } else {
            var edge = edgeExist;
            edge[triplet.predicate] = triplet.object;
            network.body.data.edges.update(edge);
          }
        }
      } else {
        console.log("import terminé")
        //  network.focus(nodeDep);
        clearInterval(this.tickInterval);
      }
    }
  }
}


//////////////////////////////////////////////////////////////////
networkDivInitialize(container, graphe){
  // create an array with nodes
  var nodes = new vis.DataSet([
    {id: 1, label: 'Organisation', color: 'rgba(97,238,195)'},
    {id: 2, label: 'Holacratie', color: 'rgba(238,97,195)'},

    {id: 3, label: 'Utilisateur', color: 'rgba(97,238,195)'},
    {id: 4, label: 'Rôle', color: 'rgba(97,238,195)'},
    {id: 5, label: 'Cercle', color: 'rgba(97,238,195)'},
    {id: 6, label: 'Domaine', color: 'rgba(97,238,195)'},
    {id: 7, label: 'Tension', color: 'rgba(97,238,195)'},
    {id: 8, label: 'Redevabilité', color: 'rgba(97,238,195)'},
    {id: 9, label: "Le rôle est l’élément central de Holacracy pour\n construire la structure organisationnelle.\nCet article couvre les autorités et devoirs de base\n d’un associé dans le cadre de l’exercice de son rôle."
    , color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 10, label: "Le Cercle contient et intègre plusieurs rôles.\nCet article décrit la façon dont un cercle\nest structuré et la façon dont les rôles sont affectés,\nélus ou formés en nouveaux sous-cercles."
    , color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 11, label: 'Processus de Gouvernance', color: 'rgba(97,238,195)'},
    {id: 12, label: "Le processus de gouvernance d’un cercle vise à définir\n ses rôles et ses politiques.\n Cet article définit le processus de gouvernance\n et les règles de base à suivre pour proposer des changements\n ou s’objecter aux propositions."
    , color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 13, label: 'Processus Opérationnel', color: 'rgba(97,238,195)'},
    {id: 14, label: "Les membres de cercle doivent s’entraider dans l’exécution\n de leur travail opérationnel.\n Cet article couvre les devoirs des membres de cercle\n pour se soutenir mutuellement, et le fonctionnement\n des réunions de triage."
    , color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 15, label: 'Description', color: 'rgba(97,238,195)', cid:1, borderWidth:3},
    {id: 16, label: 'Constitution', color: 'rgba(97,238,195)'},
    {id: 17, label: 'Règle', color: 'rgba(97,238,195)', cid:2},
    {id: 18, label: 'Processus', color: 'rgba(97,238,195)', cid:3},
    {id: 19, label: 'Ratifieur ou Associé', color: 'rgba(97,238,195)'},
    {id: 20, label: 'Entité Organisationnelle', color: 'rgba(97,238,195)'},
    {id: 21, label: 'Nom', color: 'rgba(97,238,195)'},
    {id: 22, label: "Raison d'être", color: 'rgba(97,238,195)'},

    {id: 23, label: "Capacité", color: 'rgba(97,238,195)'},
    {id: 24, label: "Potentiel", color: 'rgba(97,238,195)'},
    {id: 25, label: "But inaccessible", color: 'rgba(97,238,195)'},
    {id: 26, label: "Activité dans la durée", color: 'rgba(97,238,195)'},
    {id: 27, label: "Processer les tensions", color: 'rgba(97,238,195)'},


    {id: 28, label: "Responsabilité liée au Rôle", color: 'rgba(97,238,195)'},
    {id: 29, label: "Processer les raisons d'être et redevabilités", color: 'rgba(97,238,195)'},

    {id: 30, label: "Vous êtes chargé de suivre la façon dont la Raison d’Être\n et les Redevabilités de votre Rôle sont exprimées\n et de la comparer avec votre vision de leur manifestation potentielle idéale,\n afin d’identifier les écarts entre la réalité et le potentiel\n que vous percevez (chaque écart est une « Tension »).\n Vous êtes par ailleurs chargé de tenter de\n résoudre ces Tensions en utilisant les autorités et\n autres mécanismes dont vous disposez en vertu de la présente Constitution."
    , color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 31, label: "Vous êtes chargé d’examiner régulièrement la façon de\n mettre en œuvre la Raison d’Être et chacune\n des Redevabilités de votre Rôle.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},

    {id: 32, label: "Prochaine-Action", color: 'rgba(97,238,195)'},
    {id: 33, label: "Projet", color: 'rgba(97,238,195)'},

    {id: 34, label: "Les actions que vous pouvez exécuter immédiatement et\n dont l’exécution immédiate est fort utile,\n du moins en l’absence de\n priorités concurrentes.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 35, label: "Désignent des résultats précis qui requièrent\n l’exécution de plusieurs actions consécutives,\n et qu’il est utile de poursuivre,\n du moins en l’absence de priorités concurrentes.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},

    {id: 36, label: "Processer les projets", color: 'rgba(97,238,195)'},
    {id: 37, label: "Vous êtes chargé d’examiner régulièrement\n la façon de mener à bien chaque Projet sur\n lequel vous travaillez activement dans votre Rôle,\n en définissant notamment les éventuelles Prochaine-Actions\n utiles à l’avancement du Projet.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},


    {id: 38, label: "Suivre les Projets, les Prochaine-Actions et les Tensions", color: 'rgba(97,238,195)'},
    {id: 39, label: "Vous êtes chargé d’enregistrer et de suivre\n tous les Projets et Prochaine-Actions dans votre Rôle\n dans une base de données ou sous une forme tangible similaire,\n et de revoir régulièrement et mettre à jour cette base de données\n de façon à ce que la liste du travail encours\n et potentiel de votre Rôle demeure fiable.\n Vous êtes aussi chargé de suivre\n les Tensions identifiées dans votre Rôle,\n au moins le temps de les processer\n en Projets ou Prochaine-Actions attendus,\n ou de les résoudre autrement.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},
    {id: 40, label: "Diriger l’Attention et les Ressources", color: 'rgba(97,238,195)'},
    {id: 41, label: "À chaque fois que vous êtes disponible\n pour agir dans votre Rôle,\n vous êtes chargé d’examiner les Prochaine-Actions possibles\n que vous pourriez exécuter de façon\n efficiente et efficace à ce moment précis,\n puis d’exécuter l’action qui vous parait\n apporter le plus de valeur à l’Organisation.", color: 'rgba(97,238,195,0.5)', shape: 'box', cid: 1},

    {id: 42, label: "Base de données", color: 'rgba(97,238,195)'},
    {id: 43, label: "https://igipartners.com/constitution-holacracy", color: 'rgba(97,238,195)'},
    {id: 44, label: "Politique", color: 'rgba(97,238,195)'},
    {id: 45, label: "Forum", color: 'rgba(97,238,195)'},




  ]);

  // create an array with edges
  var edges = new vis.DataSet([
    {from: 1, to: 2, label: "utilise", array:"to"},
    {from: 2, to: 43, label: "source", array:"to"},
    {from: 1, to: 3, label: "hasPart", array:"to"},
    {from: 1, to: 4, label: "hasPart", array:"to"},
    {from: 1, to: 5, label: "hasPart", array:"to"},
    {from: 1, to: 6, label: "hasPart", array:"to"},
    {from: 1, to: 7, label: "hasPart", array:"to"},
    {from: 4, to: 5, label: "seTransformeEn", array:"to"},
    {from: 3, to: 7, label: "exprime", array:"to"},
    {from: 4, to: 9, label: "description", array:"to"},
    {from: 5, to: 10, label: "description", array:"to"},
    {from: 5, to: 11, label: "hasPart", array:"to"},
    {from: 11, to: 12, label: "description", array:"to"},
    {from: 5, to: 13, label: "hasPart", array:"to"},
    {from: 13, to: 14, label: "description", array:"to"},
    {from: 9, to: 15, label: "type", array:"to"},
    {from: 10, to: 15, label: "type", array:"to"},
    {from: 12, to: 15, label: "type", array:"to"},
    {from: 14, to: 15, label: "type", array:"to"},
    {from: 2, to: 16, label: "hasPart", array:"to"},
    {from: 16, to: 17, label: "définit", array:"to"},
    {from: 16, to: 18, label: "définit", array:"to"},
    {from: 11, to: 18, label: "type", array:"to"},
    {from: 13, to: 18, label: "type", array:"to"},
    {from: 3, to: 19, label: "subClassOf", array:"to"},
    {from: 19, to: 17, label: "adopte", array:"to"},
    {from: 17, to: 1, label: "structure d'autorité formelle de", array:"to"},
    {from: 19, to: 4, label: "agit dans le cadre d'un", array:"to"},
    {from: 19, to: 1, label: "réalise un travail pour le compte de", array:"to"},
    //ROLE
    {from: 4, to: 20, label: "subClassOf", array:"to"},
    {from: 4, to: 21, label: "hasCaractéristique", array:"to"},
    {from: 4, to: 22, label: "pousuit", array:"to"},
    {from: 4, to: 22, label: "manifeste", array:"to"},
    {from: 4, to: 8, label: "met en Oeuvre", array:"to"},

    {from: 22, to: 23, label: "subClassOf", array:"to"},
    {from: 22, to: 24, label: "subClassOf", array:"to"},
    {from: 22, to: 25, label: "subClassOf", array:"to"},

    {from: 4, to: 6, label: "contrôle", array:"to"},
    {from: 4, to: 6, label: "règlemente", array:"to"},
    //REDEVABILITE
    {from: 8, to: 26, label: "subClassOf", array:"to"},

    {from: 27, to: 28, label: "type", array:"to"},
    {from: 4, to: 27, label: "responsable de", array:"to"},
    {from: 4, to: 29, label: "responsable de", array:"to"},
    {from: 29, to: 28, label: "type", array:"to"},

    {from: 27, to: 7, label: "concerne", array:"to"},
    {from: 29, to: 22, label: "concerne", array:"to"},
    {from: 29, to: 8, label: "concerne", array:"to"},

    {from: 27, to: 30, label: "description", array:"to"},
    {from: 30, to: 15, label: "type", array:"to"},

    {from: 29, to: 31, label: "description", array:"to"},
    {from: 31, to: 15, label: "type", array:"to"},

    {from: 29, to: 32, label: "définit", array:"to"},
    {from: 29, to: 33, label: "définit", array:"to"},

    {from: 32, to: 34, label: "description", array:"to"},
    {from: 33, to: 35, label: "description", array:"to"},
    {from: 34, to: 15, label: "type", array:"to"},
    {from: 35, to: 15, label: "type", array:"to"},

    {from: 4, to: 36, label: "responsable de", array:"to"},
    {from: 36, to: 28, label: "type", array:"to"},
    {from: 36, to: 37, label: "description", array:"to"},
    {from: 37, to: 15, label: "type", array:"to"},
    {from: 36, to: 33, label: "concerne", array:"to"},
    {from: 36, to: 32, label: "définit", array:"to"},

    {from: 4, to: 38, label: "responsable de", array:"to"},
    {from: 38, to: 28, label: "type", array:"to"},
    {from: 38, to: 39, label: "description", array:"to"},
    {from: 39, to: 15, label: "type", array:"to"},
    {from: 38, to: 33, label: "enregistre", array:"to"},
    {from: 38, to: 32, label: "enregistre", array:"to"},
    {from: 38, to: 33, label: "suit", array:"to"},
    {from: 38, to: 32, label: "suit", array:"to"},
    {from: 38, to: 7, label: "suit", array:"to"},
    {from: 38, to: 42, label: "actualise", array:"to"},
    {from: 32, to: 42, label: "stocké dans", array:"to"},
    {from: 33, to: 42, label: "stocké dans", array:"to"},


    {from: 4, to: 40, label: "responsable de", array:"to"},
    {from: 40, to: 28, label: "type", array:"to"},
    {from: 40, to: 41, label: "description", array:"to"},
    {from: 41, to: 15, label: "type", array:"to"},

    //responsabilités liées au rôle
    {from: 28, to: 27, label: "first", array:"to"},
    {from: 27, to: 29, label: "next", array:"to"},
    {from: 29, to: 36, label: "next", array:"to"},
    {from: 36, to: 38, label: "next", array:"to"},
    {from: 38, to: 40, label: "next", array:"to"},

    {from: 40, to: 32, label: "examine", array:"to"},
    {from: 4, to: 32, label: "execute", array:"to"},

    {from: 32, to: 22, label: "exprime", array:"to"},
    {from: 32, to: 8, label: "exprime", array:"to"},

    //Politique
    {from: 4, to: 44, label: "définit", array:"to"},
    {from: 4, to: 44, label: "publie", array:"to"},
    {from: 44, to: 6, label: "appliqué à", array:"to"},
    {from: 44, to: 45, label: "publié sur", array:"to"},
    {from: 19, to: 45, label: "consulte", array:"to"},



  ]);
  var data = {
    nodes: nodes,
    edges: edges
  };
  var options = {
    edges:{
      arrows: {
        to:     {enabled: true, scaleFactor:1, type:'arrow'},
        middle: {enabled: false, scaleFactor:1, type:'arrow'},
        from:   {enabled: false, scaleFactor:1, type:'arrow'}
      }},

      interaction:{
        navigationButtons: true,
        //  keyboard: true  //incompatible avec rappel de commande en cours d'implémentation
      },
      manipulation: {
        addNode: function (data, callback) {
          // filling in the popup DOM elements
          data.label = "";
          //  console.log(this);
          graphe.editNode(data, callback);
        },
        editNode: function (data, callback) {
          // filling in the popup DOM elements
          //document.getElementById('nodeOperation').innerHTML = "Edit Node";
          graphe.$.nodeOperation.innerHTML = "Edit Node";
          graphe.editNode(data, callback);
        },
        deleteNode: function (data, callback) {
          // filling in the popup DOM elements
          graphe.deleteNode(data, callback);
        },
        addEdge: function (data, callback) {
          if (data.from == data.to) {
            var r = confirm("Êtes-vous certain de vouloir connecter le noeud à lui-même?");
            if (r != true) {
              callback(null);
              return;
            }
          }
          //document.getElementById('edgeOperation').innerHTML = "Add Edge";
          graphe.$.edgeOperation.innerHTML = "Add Edge";
          graphe.editEdgeWithoutDrag(data, callback);
        },
        editEdge: {
          editWithoutDrag: function(data, callback) {
            //document.getElementById('edgeOperation').innerHTML = "Edit Edge";
            graphe.$.edgeOperation.innerHTML = "Edit Edge";
            graphe.editEdgeWithoutDrag(data,callback);
          }
        },
        deleteEdge: function(data,callback){
          graphe.deleteEdge(data,callback);
        }
      },
      physics:{
        enabled: true,
        barnesHut: {
          gravitationalConstant: -1,
          centralGravity: 0.3,
          springLength: 95,
          springConstant: 0.04,
          damping: 0.09,
          avoidOverlap: 1
        },
        forceAtlas2Based: {
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springConstant: 0.08,
          springLength: 100,
          damping: 0.4,
          avoidOverlap: 0
        },
        repulsion: {
          centralGravity: 0.001, //0.001 ? A quoi sert cette valeur ?
          springLength: 220, //220 (//200 //300)
          springConstant: 0.01, //0.01
          nodeDistance: 150, //100 //350
          damping: 0.08
        },
        hierarchicalRepulsion: {
          centralGravity: 0.0,
          springLength: 100,
          springConstant: 0.01,
          nodeDistance: 120,
          damping: 0.09
        },
        maxVelocity: 500, //50
        minVelocity: 1, //0.1
        solver: 'repulsion',
        stabilization: {
          enabled: true,
          iterations: 1000,
          updateInterval: 100,
          onlyDynamicEdges: false,
          fit: true
        },
        timestep: 0.5,
        adaptiveTimestep: true
      }
    };
    return new vis.Network(container, data, options);
  }

  editNode (data, callback) {
    //console.log(data);
    this.$.nodeLabel.value= data.label || "";
    this.$.nodeSaveButton.onclick = this.saveNodeData.bind(this, data, callback);
    this.$.nodeLabel.onchange = this.saveNodeData.bind(this, data, callback);
    this.$.nodeCancelButton.onclick = this.clearNodePopUp.bind(this);
    this.$.nodePopUp.style.display = 'block';
    this.$.nodeLabel.focus();
  }

  clearNodePopUp () {
    this.$.nodeSaveButton.onclick = null;
    this.$.nodeCancelButton.onclick = null;
    this.$.nodePopUp.style.display = 'none';
  }

  cancelNodeEdit (callback) {
    this.clearNodePopUp(this);
    callback(null);
  }

  saveNodeData (data, callback) {
    data.label = this.$.nodeLabel.value;
    if (data.label.length > 40){
      var titleTemp =data.label.match(/.{1,40}/g);
      //  console.log(titleTemp);
      data.label = titleTemp.join("\n");
      data.shape = "box";
      //  data.mass = 1/data.label.length
    }
    this.clearNodePopUp(this);
    callback(data);
    var node = this.network.body.data.nodes.get(data.id);
    //console.log(node);
    var action = {};
    action.type = "newNode";
    action.data = node;
    this.addAction(action);
  }

  addAction(action){
    //  var actionstosendTemp = catchTriplet(message, network, actionstosend);
    //  var actionstosendTemp = catchTriplet(message, network);
    var actionstosendTemp = this.actionstosend;
    this.actionstosend = [];
    actionstosendTemp.push(action);
    this.actionstosend = actionstosendTemp;
    //  console.log(this.actionstosend);
    /*if ((actionstosendTemp != undefined) && (actionstosendTemp.length > 0)) {
    actionstosend = actionstosend.concat(actionstosendTemp);
    console.log("send");
    console.log(actionstosend);
  }*/
}

editEdgeWithoutDrag (data, callback) {
  this.$.edgeLabel.value = data.label || "";
  this.$.edgeSaveButton.onclick = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeLabel.onchange = this.saveEdgeData.bind(this, data, callback);
  this.$.edgeCancelButton.onclick = this.cancelEdgeEdit.bind(this,callback);
  this.$.edgePopUp.style.display = 'block';
  this.$.edgeLabel.focus();
}

clearEdgePopUp () {
  this.$.edgeSaveButton.onclick = null;
  this.$.edgeCancelButton.onclick = null;
  this.$.edgePopUp.style.display = 'none';
}

cancelEdgeEdit (callback) {
  this.clearEdgePopUp();
  callback(null);
}

saveEdgeData (data, callback) {
  if (typeof data.to === 'object')
  data.to = data.to.id
  if (typeof data.from === 'object')
  data.from = data.from.id
  data.label = this.$.edgeLabel.value;
  this.clearEdgePopUp();
  callback(data);
  var edge = this.network.body.data.edges.get({
    filter: function(edge) {
      return (edge.from == data.from && edge.to == data.to && edge.label == data.label);
    }
  });
  var action = {};
  action.type = "newEdge";
  action.data = edge;
  this.addAction(action);
}


deleteNode (data, callback){
  //console.log(data);
  var action = {};
  action.type = "deleteNode";
  action.data = data;
  this.addAction(action);
  callback(data);
}

deleteEdge (data, callback){
  //console.log(data);
  var action = {};
  action.type = "deleteEdge";
  action.data = data;
  this.addAction(action);
  callback(data);
}
/*A RAJOUTER
document.getElementById("importCancelButton").onclick = function (){
document.getElementById('importPopUp').style.display = 'none';
}*/

/*
document.getElementById("toggleMessagesDiv").onclick = function (){
document.getElementById('chatArea').style.height = '30px';
}*/




addEdgeIfNotExist (network, data){
  var existEdge = false;
  try {
    existEdge = this.network.body.data.edges.get({
      filter: function(edge){
        return (edge.id == data[0].id);
      }
    });
    if (existEdge.length == 0){
      this.network.body.data.edges.add(data[0]);
    }else{
      //s'il existe déjà, ne serait-ce pas un renommage ?
      //  console.log("renomme");
      //  console.log(data);
      //existNode[0].label = data.label;
      //  editNode(data, null);
      //    console.log(this.network.body.data.edges);
      this.network.body.data.edges.update({id: data[0].id, label: data[0].label});
      //  console.log(this.network.body.data.edges);
    }
  }
  catch (err) {
    console.log(err);
  }
}

addNodeIfNotExist(network, data){
  var existNode = false;
  //  console.log(data);
  try{
    existNode = this.network.body.data.nodes.get({
      filter: function(node){
        //    console.log(node);
        return (node.id == data.id );
      }
    });
    //  console.log(existNode);
    if (existNode.length == 0){
      this.network.body.data.nodes.add({id: data.id, label: data.label});
    }else{
      //s'il existe déjà, ne serait-ce pas un renommage ?
      //  console.log("renomme");
      //  console.log(data);
      //existNode[0].label = data.label;
      //  editNode(data, null);
      //  console.log(this.network.body.data.nodes);
      this.network.body.data.nodes.update({id: data.id, label: data.label});
    }
  }
  catch (err){
    console.log(err);
  }
}

deleteFromServer (data){
  //Pour suppression, on recupere le noeud et ses liens envoyés par le serveur
  this.network.body.data.nodes.remove(data.nodes);
  this.network.body.data.edges.remove(data.edges);
}

_changeGravity(e){
  this.network.physics.options.repulsion.centralGravity = this.gravityValue;
}

_changeSpringLength(){
  this.network.physics.options.repulsion.springLength = this.springLengthValue;
}

_changeSpringConstant(){
  this.network.physics.options.repulsion.springConstant = this.springConstantValue;
}

_changeNodeDistance(){
  this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValue;
}

_changeDamping(){
  this.network.physics.options.repulsion.damping = this.dampingValue;
}

_defaultPhysicValues(){
  /*valeurs par Defaut de network.physics.repulsion
  centralGravity: 0.001,
  springLength: 220, //200 //300
  springConstant: 0.005,
  nodeDistance: 180, //100 //350
  damping: 0.08*/
  this.gravityValue = 0.001;
  this.network.physics.options.repulsion.centralGravity = this.gravityValue;
  this.springLengthValue = 200;
  this.network.physics.options.repulsion.springLength = this.springLengthValue;
  this.springConstantValue = 0.01;
  this.network.physics.options.repulsion.springConstant = this.springConstantValue;
  this.nodeDistanceValue = 150;
  this.network.physics.options.repulsion.nodeDistance = this.nodeDistanceValue;
  this.dampingValue = 0.08;
  this.network.physics.options.repulsion.damping = this.dampingValue;
}


_toggleSettings(){
  console.log(this.$.settings.hidden);
  this.$.settings.hidden= !this.$.settings.hidden;
}

// CLUSTERS
_toggleDesc() {
  //  network.setData(data);
  var clusterOptionsByData = {
    joinCondition:function(childOptions) {
      return childOptions.cid == 1;
    },
    processProperties: function (clusterOptions, childNodes) {

      //clusterIndex = clusterIndex + 1;
      var clusterIndex = 1
      var childrenCount = 0;
      for (var i = 0; i < childNodes.length; i++) {
        childrenCount += childNodes[i].childrenCount || 1;
      }
      clusterOptions.childrenCount = childrenCount;
      clusterOptions.label = "Description\n# " + childrenCount + "";
      // clusterOptions.font = {size: childrenCount*5+30}
      clusterOptions.id = 'cluster:' + clusterIndex;
      clusterOptions.mass = 1/childrenCount;
      // clusters.push({id:'cluster:' + clusterIndex, scale:scale});
      return clusterOptions;
    },
    clusterNodeProperties: {id:'cidCluster',  color: 'rgba(97,238,195,0.5)', borderWidth:3, shape:'box'}
  };
  this.network.cluster(clusterOptionsByData);
}



}

window.customElements.define(SpogGraphe.is, SpogGraphe);
</script>
</dom-module>
